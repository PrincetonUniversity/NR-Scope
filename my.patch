diff --git a/lib/src/phy/ue/ue_sync_nr.c b/lib/src/phy/ue/ue_sync_nr.c
index eeb5de2..3768eec 100644
--- a/lib/src/phy/ue/ue_sync_nr.c
+++ b/lib/src/phy/ue/ue_sync_nr.c
@@ -229,7 +229,7 @@ static int ue_sync_nr_run_track(srsran_ue_sync_nr_t* q, cf_t* buffer)
   }
 
   if (!is_ssb_opportunity) {
-    // printf("!is_ssb_opportunity triggered\n");
+    printf("!is_ssb_opportunity triggered\n");
     return SRSRAN_SUCCESS;
   }
 
@@ -394,26 +394,23 @@ int srsran_ue_sync_nr_zerocopy_twinrx(srsran_ue_sync_nr_t* q, cf_t** buffer, srs
   }
 
   // Run FSM
-  u_int32_t actual_sf_sz = 0;
   switch (q->state) {
     case SRSRAN_UE_SYNC_NR_STATE_IDLE:
       // Do nothing
       break;
     case SRSRAN_UE_SYNC_NR_STATE_FIND:
       // resample 
-      msresamp_crcf_execute(rk->resampler, buffer[0], PRE_RESAMPLING_SF_SZ, buffer[0], &actual_sf_sz);
-      // printf("[xuyang debug] find state actual_sf_sz %u\n", actual_sf_sz);
-      // srsran_vec_cf_copy(buffer[0], rk->temp_y, actual_sf_sz);  
+      u_int32_t actual_sf_sz = 0;
+      msresamp_crcf_execute(rk->resampler, buffer[0], PRE_RESAMPLING_SF_SZ, rk->temp_y, &actual_sf_sz);
+      printf("[xuyang debug] nice actual_sf_sz %u\n", actual_sf_sz);
+      srsran_vec_cf_copy(buffer[0], rk->temp_y, actual_sf_sz);  
+
       if (ue_sync_nr_run_find(q, buffer[0]) < SRSRAN_SUCCESS) {
         ERROR("Error running find");
         return SRSRAN_ERROR;
       }
       break;
     case SRSRAN_UE_SYNC_NR_STATE_TRACK:
-      // resample 
-      // msresamp_crcf_execute(rk->resampler, buffer[0], PRE_RESAMPLING_SF_SZ, buffer[0], &actual_sf_sz);
-      // printf("[xuyang debug] track state actual_sf_sz %u\n", actual_sf_sz);
-      // srsran_vec_cf_copy(buffer[0], rk->temp_y, actual_sf_sz);  
       if (ue_sync_nr_run_track(q, buffer[0]) < SRSRAN_SUCCESS) {
         ERROR("Error running track");
         return SRSRAN_ERROR;
diff --git a/nrscope/hdr/task_scheduler.h b/nrscope/hdr/task_scheduler.h
index 6ec9f00..1801fe0 100644
--- a/nrscope/hdr/task_scheduler.h
+++ b/nrscope/hdr/task_scheduler.h
@@ -83,7 +83,6 @@ class TaskSchedulerNRScope{
     std::complex<float> * temp_x;
     std::complex<float> * temp_y;
     uint32_t pre_resampling_slot_sz;
-    uint32_t pre_resampling_sf_sz;
 };
 
 
diff --git a/nrscope/src/libs/rach_decoder.cc b/nrscope/src/libs/rach_decoder.cc
index b322808..efca0fd 100644
--- a/nrscope/src/libs/rach_decoder.cc
+++ b/nrscope/src/libs/rach_decoder.cc
@@ -409,6 +409,8 @@ int RachDecoder::decode_and_parse_msg4_from_slot(srsran_slot_cfg_t* slot,
     asn1::rrc_nr::dl_ccch_msg_s dlcch_msg;
     // What the first few bytes are? In srsgNB there are 10 extra bytes and for small cell there are 3 extra bytes
     // before the RRCSetup message.
+    std::cout << "decoding rrcsetup bytes_offset: " << bytes_offset << std::endl;
+    bytes_offset = 1;
     asn1::cbit_ref dlcch_bref(pdsch_res.tb[0].payload + bytes_offset, pdsch_cfg.grant.tb[0].tbs / 8 - bytes_offset);
     asn1::SRSASN_CODE err = dlcch_msg.unpack(dlcch_bref);
     if (err != asn1::SRSASN_SUCCESS) {
diff --git a/nrscope/src/libs/radio_nr.cc b/nrscope/src/libs/radio_nr.cc
index 757517b..ecd419d 100644
--- a/nrscope/src/libs/radio_nr.cc
+++ b/nrscope/src/libs/radio_nr.cc
@@ -657,67 +657,31 @@ int Radio::RadioCapture(){
 
   bool someone_already_resampled;
 
-  cf_t * rx_buffer_begin = rx_buffer;
+  while(true){
+    outcome.timestamp = last_rx_time.get(0);  
 
-  int i = 0;
+    struct timeval t0, t1;
+    gettimeofday(&t0, NULL);    
 
-  while(true){
-    i++;
-    struct timeval t0, t1, t2;
-    gettimeofday(&t0, NULL);
-    outcome.timestamp = last_rx_time.get(0);      
+    someone_already_resampled = false;
 
     if (srsran_ue_sync_nr_zerocopy_twinrx(&ue_sync_nr, rf_buffer_t.to_cf_t(), &outcome, &rk) < SRSRAN_SUCCESS) {
       std::cout << "SYNC: error in zerocopy" << std::endl;
       logger.error("SYNC: error in zerocopy");
       return false;
     }
-
-    gettimeofday(&t2, NULL);  
-    // result.processing_time_us = t1.tv_usec - t0.tv_usec;   
-    std::cout << "sample fetch time_spend: " << (t2.tv_usec - t0.tv_usec) << "(us)" << std::endl;
-
     // If in sync, update slot index. The synced data is stored in rf_buffer_t.to_cf_t()[0]
     if (outcome.in_sync){
-
-      // if (i % 2 == 1) {
-      //   continue;
-      // }
-      // std::cout << "System frame idx: " << outcome.sfn << std::endl;
-      // std::cout << "Subframe idx: " << outcome.sf_idx << std::endl;
-      // std::cout << "Sync delay: " << outcome.delay_us << std::endl;
-
-      // uint32_t actual_sf_sz = 0;
-      // copy_c_to_cpp_complex_arr_and_zero_padding(rx_buffer, task_scheduler_nrscope.temp_x, task_scheduler_nrscope.pre_resampling_sf_sz, task_scheduler_nrscope.temp_x_sz);
-      // msresamp_crcf_execute(task_scheduler_nrscope.resampler, task_scheduler_nrscope.temp_x, task_scheduler_nrscope.pre_resampling_sf_sz, task_scheduler_nrscope.temp_y, &actual_sf_sz);
-      // // std::cout << "main thread resampled: " << actual_sf_sz << std::endl;
-      // copy_cpp_to_c_complex_arr(task_scheduler_nrscope.temp_y, rx_buffer, actual_sf_sz);      
-      someone_already_resampled = false;
+      std::cout << "System frame idx: " << outcome.sfn << std::endl;
+      std::cout << "Subframe idx: " << outcome.sf_idx << std::endl;
+      std::cout << "Sync delay: " << outcome.delay_us << std::endl;
 
       for(int slot_idx = 0; slot_idx < SRSRAN_NOF_SLOTS_PER_SF_NR(arg_scs.scs); slot_idx++){
         srsran_slot_cfg_t slot = {0};
         slot.idx = (outcome.sf_idx) * SRSRAN_NSLOTS_PER_FRAME_NR(arg_scs.scs) / 10 + slot_idx;
         // Move rx_buffer
         srsran_vec_cf_copy(rx_buffer, rx_buffer + slot_idx*pre_resampling_slot_sz, pre_resampling_slot_sz);  
-
-        // if (i % 2 == 1) {
-        //   if (slot_idx == 0) {
-        //     someone_already_resampled = false;
-        //   }
-        //   if (slot_idx == 1) {
-        //     someone_already_resampled = true;
-        //   }
-        // }
-        // else {
-        //   if (slot_idx == 0) {
-        //     someone_already_resampled = true;
-        //   }
-        //   if (slot_idx == 1) {
-        //     someone_already_resampled = false;
-        //   }
-        // }
-        // save copy
-        // rx_buffer = rx_buffer_begin + slot_idx*slot_sz;
+        
 
         // fseek(fp, file_position * sizeof(cf_t), SEEK_SET);
         // // uint32_t a = fread(ue_dl.fft[0].cfg.in_buffer, sizeof(cf_t), ue_dl.fft[0].sf_sz, fp);
@@ -856,12 +820,11 @@ int Radio::RadioCapture(){
           }
         }
         task_scheduler_nrscope.update_known_rntis();
+        gettimeofday(&t1, NULL);  
+        // result.processing_time_us = t1.tv_usec - t0.tv_usec;   
+        std::cout << "time_spend: " << (t1.tv_usec - t0.tv_usec) << "(us)" << std::endl;
       } 
-      
     } 
-    gettimeofday(&t1, NULL);  
-    // result.processing_time_us = t1.tv_usec - t0.tv_usec;   
-    std::cout << "time_spend: " << (t1.tv_usec - t0.tv_usec) << "(us)" << std::endl;
   }
   // fclose(fp);
   // fclose(fp2);
diff --git a/nrscope/src/libs/task_scheduler.cc b/nrscope/src/libs/task_scheduler.cc
index 6ff0a62..8ba944b 100644
--- a/nrscope/src/libs/task_scheduler.cc
+++ b/nrscope/src/libs/task_scheduler.cc
@@ -118,8 +118,7 @@ int TaskSchedulerNRScope::decode_mib(cell_searcher_args_t* args_t_,
   resampler = msresamp_crcf_create(resample_ratio,As);
   resampler_delay = msresamp_crcf_get_delay(resampler);
   pre_resampling_slot_sz = 25000000 / 2000; // don't hardcode it; change later
-  pre_resampling_sf_sz = 25000000 / 1000;
-  temp_x_sz = pre_resampling_sf_sz + (int)ceilf(resampler_delay) + 10;
+  temp_x_sz = pre_resampling_slot_sz + (int)ceilf(resampler_delay) + 10;
   temp_y_sz = (uint32_t)(temp_x_sz * resample_ratio * 2);
   temp_x = SRSRAN_MEM_ALLOC(std::complex<float>, temp_x_sz);
   temp_y = SRSRAN_MEM_ALLOC(std::complex<float>, temp_y_sz);
